# Objective-Z

Objective-C runtime for Zephyr RTOS.

Ported from [djthorpe/objc](https://github.com/djthorpe/objc) (minimal GCC-compatible ObjC runtime), packaged as a Zephyr module. Uses the gnustep-2.0 ABI with Clang for ObjC compilation.

## Motivation

### Why another runtime?

Existing Objective-C runtimes — Apple libobjc, GNUstep libobjc2, ObjFW, mulle-objc — assume a general-purpose heap. All dispatch tables, class tables, selector tables, and object instances are `malloc`'d at runtime. This is fine for desktop/mobile but incompatible with deterministic embedded firmware on MCUs with 64–512 KB RAM and no MMU.

### Static-first design

Objective-Z inverts this: all runtime tables (class, selector, category, hash, dispatch) are statically sized at build time via tree-sitter AST analysis and allocated in BSS. Object instances are served from Zephyr `K_MEM_SLAB` pools (also BSS), auto-generated by `objz_gen_pools.py` from Clang AST analysis that counts max concurrent instances per class. Heap exists only as a bounded fallback (`sys_heap`, default 4 KB).

### No dynamic ObjC magic

Features that require unbounded runtime allocation — KVO, method swizzling, dynamic class creation, associated objects, weak references, message forwarding — are removed. Only the core language features that can be fully resolved at load time remain: message dispatch, ARC, categories, protocols, blocks.

### Zephyr-native

Built on Zephyr primitives (`K_MEM_SLAB`, `SYS_INIT`, `k_spinlock_t`, `atomic_t`), not POSIX. No libc `malloc` dependency.

## How It Compares

### Runtime Features

| Feature | Apple libobjc | GNUstep libobjc2 | ObjFW | mulle-objc | Objective-Z |
|---|---|---|---|---|---|
| Target | macOS/iOS | Linux/Windows | Portable desktop + consoles | Anywhere C runs | Zephyr RTOS (Cortex-M) |
| Object allocation | Heap (`malloc_zone`) | Heap (`malloc`) | Heap (`malloc`) | Heap (`malloc`) | Static `K_MEM_SLAB` pools; heap fallback |
| Dispatch tables | Heap, dynamic | Heap sparse array | Heap 2/3-level array | Heap hash | Static BSS, per-class sized at build time |
| Runtime tables | Heap / VM | Heap | Heap | Heap | Static BSS, auto-computed via tree-sitter |
| Build-time sizing | No | No | No | No | Yes (tree-sitter + Clang AST) |
| Dynamic class creation | Yes | Yes | Yes | Limited | No |
| Method swizzling | Yes | Yes | Yes | Discouraged | No |
| KVO | Yes (isa-swizzling) | Yes | Minimal | No | No |
| Weak references | Yes | Yes | Yes | No | No |
| Associated objects | Yes | Yes | Yes | No | No |
| Message forwarding | Yes | Yes | Yes (platform-dep.) | No | No |
| ARC | Yes | Yes | Yes | AAM / optional | Yes (always on) |
| Blocks | Yes | Yes | Yes | Partial | Yes (optional) |
| RTOS integration | No | No | No | No | Yes (Zephyr-native) |

### Foundation / Class Library

| Class | Apple (NS\*) | GNUstep (NS\*) | ObjFW (OF\*) | mulle-objc | Objective-Z (OZ\*) |
|---|---|---|---|---|---|
| Root class | NSObject | NSObject | OFObject | MulleObject | Object |
| String | NSString | NSString | OFString | MulleObjCString | OZString |
| Mutable string | NSMutableString | NSMutableString | OFMutableString | Yes | OZMutableString |
| Number | NSNumber | NSNumber | OFNumber | MulleObjCNumber | OZNumber |
| Array | NSArray | NSArray | OFArray | MulleObjCArray | OZArray |
| Dictionary | NSDictionary | NSDictionary | OFDictionary | MulleObjCDictionary | OZDictionary |
| Autorelease pool | `@autoreleasepool` | `@autoreleasepool` | OFAutoreleasePool | MulleObjCAutoreleasePool | OZAutoreleasePool |
| Logging | NSLog | NSLog | OFLog | — | OZLog |
| Networking | NSURLSession | NSURLConnection | OFHTTPClient | — | — |
| File I/O | NSFileManager | NSFileManager | OFFile | — | — |
| Threading | NSThread | NSThread | OFThread | MulleThread | Zephyr `k_thread` |
| KVC/KVO | Yes | Yes | Partial KVC | No | No |
| Scope | Full framework | Full framework | Full framework | Medium framework | Minimal embedded core |

## Features

- Class and instance method dispatch (`objc_msg_lookup` / `objc_msgSend`)
- Categories and protocols
- `@"..."` string literals (OZString / NSString alias under Clang)
- Boxed literals (`@42`, `@YES`, `@3.14`) and collection literals (`@[...]`, `@{...}`)
- Blocks (closures) with `-fblocks` — global, stack, and heap blocks with `__block` variable support
- Fast enumeration (`for...in` loops) on OZArray and OZDictionary
- `enumerateObjectsUsingBlock:` for block-based iteration
- Automatic Reference Counting (ARC) with `-fobjc-arc`
- `@autoreleasepool` blocks via per-thread pool stack
- Static allocation pools using Zephyr `K_MEM_SLAB` — zero heap allocation per class
- `OZLog()` with `%@` format specifier and `-description` support
- Zephyr zbus integration examples (pub/sub and request-response)
- ARM Cortex-M Thumb-2 `objc_msgSend` trampoline for gnustep-2.0 direct dispatch

## Prerequisites

- [Zephyr SDK](https://docs.zephyrproject.org/latest/develop/getting_started/index.html) and `west`
- Clang (for compiling `.m` files with gnustep-2.0 ABI)
- Python 3 with `tree-sitter` and `tree-sitter-objc` (`pip install -r objc/scripts/requirements.txt`)
- [just](https://github.com/casey/just) (build automation, optional)

## Quick Start

Build and run the hello_world sample in QEMU:

```sh
# Build
west build -p -b mps2/an385 samples/hello_world

# Run in QEMU
west build -t run
```

Or with `just`:

```sh
just rebuild
just run
```

Expected output:

```
Hello, world from class
Hello, world from object
```

Exit QEMU with `Ctrl+A`, then `x`.

## Samples

| Sample | Description | Kconfig |
|---|---|---|
| `hello_world` | Basic class/instance method dispatch | `CONFIG_OBJZ=y` |
| `hello_category` | Categories (method extensions on existing classes) | `CONFIG_OBJZ=y` |
| `mem_demo` | ARC lifecycle: scope-based cleanup, autorelease pools | `CONFIG_OBJZ=y` |
| `arc_demo` | Automatic Reference Counting, scoped cleanup | `+OBJZ_ARC` |
| `pool_demo` | Static allocation pools with `K_MEM_SLAB` | `+OBJZ_STATIC_POOLS` |
| `literals_demo` | Boxed literals and collection literals (`@42`, `@[...]`, `@{...}`) | `+OBJZ_COLLECTIONS +OBJZ_NUMBERS +OBJZ_LITERALS` |
| `blocks_demo` | Blocks, `__block` variables, fast enumeration, `enumerateObjectsUsingBlock:` | `+OBJZ_BLOCKS +OBJZ_COLLECTIONS +OBJZ_NUMBERS +OBJZ_LITERALS` |
| `generics_demo` | Lightweight generics with typed collections | `+OBJZ_BLOCKS +OBJZ_COLLECTIONS +OBJZ_NUMBERS +OBJZ_LITERALS` |
| `zbus_objc` | ObjC objects with Zephyr zbus pub/sub messaging | `+ZBUS` |
| `zbus_service` | Request-response service pattern over zbus | `+ZBUS` |
| `benchmark` | Cycle-accurate runtime performance benchmarks | `+OBJZ_ARC +OBJZ_BLOCKS +OBJZ_STATIC_POOLS` |

Build a specific sample:

```sh
just project_dir=samples/arc_demo rebuild
just run
```

### hello_world

```objc
#import <objc/objc.h>

@interface MyFirstObject : Object
- (void)greet;
+ (void)greet;
@end

@implementation MyFirstObject
- (void)greet { OZLog("Hello, world from object"); }
+ (void)greet { OZLog("Hello, world from class"); }
@end

int main(void) {
    [MyFirstObject greet];
    MyFirstObject *hello = [[MyFirstObject alloc] init];
    [hello greet];
    [hello dealloc];
    return 0;
}
```

## Benchmark

The `benchmark` sample measures key runtime operations with cycle-accurate timing using the DWT cycle counter. Results below are from QEMU (mps2/an385, ARM Cortex-M3, 25 MHz):

```sh
just project_dir=samples/benchmark rebuild
just run
```

### Message Dispatch

With dispatch cache (`CONFIG_OBJZ_DISPATCH_CACHE=y`, default):

| Operation | Cycles | ns |
|---|---:|---:|
| C function call (baseline, cached IMP) | 13 | 520 |
| `objc_msgSend` (instance method) | 298 | 11,920 |
| `objc_msgSend` (class method) | 231 | 9,240 |
| `objc_msgSend` (inherited depth=1) | 299 | 11,960 |
| `objc_msgSend` (inherited depth=2) | 298 | 11,920 |
| `objc_msgSend` (cold cache, depth=0) | 1,636 | 65,440 |
| `objc_msgSend` (cold cache, depth=2) | 2,410 | 96,400 |

Without dispatch cache (`CONFIG_OBJZ_DISPATCH_CACHE=n`):

| Operation | Cycles | ns |
|---|---:|---:|
| C function call (baseline, cached IMP) | 13 | 520 |
| `objc_msgSend` (instance method) | 560 | 22,400 |
| `objc_msgSend` (class method) | 743 | 29,720 |
| `objc_msgSend` (inherited depth=1) | 887 | 35,480 |
| `objc_msgSend` (inherited depth=2) | 1,328 | 53,120 |
| `objc_msgSend` (cold cache, depth=0) | 571 | 22,840 |
| `objc_msgSend` (cold cache, depth=2) | 1,338 | 53,520 |

### Object Lifecycle

| Operation | Cached | No cache | Unit |
|---|---:|---:|---|
| alloc/init/release (heap) | 5,607 | 6,685 | cycles |
| alloc/init/release (static pool) | 3,280 | 4,608 | cycles |

### Reference Counting

| Operation | Cycles | ns |
|---|---:|---:|
| retain (via dispatch) | 240 | 9,600 |
| retain + release pair | 320 | 12,800 |
| `objc_retain` (ARC, direct C call) | 58 | 2,320 |
| `objc_release` (ARC) | 135 | 5,400 |
| `objc_storeStrong` (ARC) | 221 | 8,840 |

### Introspection

| Operation | Cached | No cache | Unit |
|---|---:|---:|---|
| `class_respondsToSelector` (YES) | 167 | 503 | cycles |
| `class_respondsToSelector` (NO) | 1,348 | 1,195 | cycles |
| `object_getClass` | 20 | 20 | cycles |

### Blocks

| Operation | Cycles | ns |
|---|---:|---:|
| C function pointer call (baseline) | 10 | 400 |
| Global block invocation | 20 | 800 |
| Heap block invocation (int capture) | 20 | 800 |
| `_Block_copy` + `_Block_release` (int capture) | 414 | 16,560 |
| `_Block_copy` (retain heap block) | 48 | 1,920 |

### Block Memory

| Metric | Size |
|---|---:|
| C function pointer | 4 B |
| Block pointer (reference) | 4 B |
| `struct Block_layout` | 20 B |
| Block + int capture (descriptor size) | 24 B |
| Block + ObjC object capture (descriptor size) | 24 B |
| Block + `__block` int (descriptor size) | 24 B |
| Heap cost: `_Block_copy` (int capture) | 32 B |
| Heap cost: `_Block_copy` (obj capture) | 32 B |
| Heap cost: `_Block_copy` (`__block` int) | 56 B |

### Logging

Comparison of `printk`, Zephyr `LOG_INF` (minimal mode), and `OZLog` (50 iterations).
`OZLog` uses `-cDescription:maxLength:` for zero-alloc `%@` formatting (no autorelease pool or heap strings):

| Operation | Cycles | ns |
|---|---:|---:|
| `printk` (simple string) | 2,301 | 92,040 |
| `LOG_INF` (simple string) | 2,903 | 116,120 |
| `OZLog` (simple string) | 3,280 | 131,200 |
| `printk` (integer format) | 2,196 | 87,840 |
| `LOG_INF` (integer format) | 2,797 | 111,880 |
| `OZLog` (integer format) | 3,883 | 155,320 |
| `printk` (string format) | 2,039 | 81,560 |
| `LOG_INF` (string format) | 2,640 | 105,600 |
| `OZLog` (string format) | 3,892 | 155,680 |
| `OZLog` (`%@` object format) | 2,992 | 119,680 |

### Memory Footprint

Runtime cost vs bare Zephyr (mps2/an385, benchmark sample with all features):

| Configuration | FLASH | RAM | FLASH delta | RAM delta |
|---|---:|---:|---:|---:|
| Bare Zephyr (no ObjC) | 12,104 B | 6,120 B | — | — |
| All features enabled | 39,404 B | 23,604 B | +27,300 B | +17,484 B |

Dispatch cache cost (`CONFIG_OBJZ_DISPATCH_CACHE`, default `y`):

| Metric | Cached | No cache | Delta |
|---|---:|---:|---:|
| FLASH | 39,404 B | 38,384 B | +1,020 B |
| RAM (BSS + data) | 23,604 B | 22,180 B | +1,424 B |

Blocks runtime cost (`CONFIG_OBJZ_BLOCKS`, default `n`):

| Metric | Blocks on | Blocks off | Delta |
|---|---:|---:|---:|
| FLASH | 39,404 B | 36,412 B | +2,992 B |
| RAM (BSS + data) | 23,604 B | 23,580 B | +24 B |

**Key takeaways:**

- **Dispatch cache cuts overhead from ~43x to ~23x** a direct C function call. The per-class dispatch table (`CONFIG_OBJZ_DISPATCH_CACHE`) resolves method lookups via pointer hashing after the first call. Cold-cache sends fall back to the global hash table with `strcmp` matching.
- **Inheritance depth is free** after warm-up: cached inherited methods (depth=1, depth=2) all resolve in ~298 cycles, the same as direct methods. The IMP is cached at the receiver's class level, eliminating the superclass chain walk. Without cache, each level adds ~150-400 cycles.
- **Cache cost:** +1,424 B RAM (per-class sized static dtables), +1,020 B FLASH (code + registry). Per-class dtable sizing via `OZ_DEFINE_DTABLE` — each class gets a table sized to its method count instead of a single global size.
- **ARC retain vs message dispatch**: `objc_retain` (58 cycles) vs `[obj retain]` (240 cycles cached) — ARC entry points bypass message dispatch entirely.
- **Static pools are ~41% faster** than heap allocation (`sys_heap` with spinlock).
- **Block invocation matches C function pointers** at 20 cycles (vs 10 for a raw `call`). The overhead comes from `_Block_copy` (stack-to-heap promotion): 414 cycles per copy, but retaining an already-heap block is only 48 cycles. Each heap block costs 32 B (56 B with `__block` variables due to the `Block_byref` structure).
- **OZLog vs printk**: OZLog is ~1.4x `printk` for simple strings thanks to zero-alloc `-cDescription:maxLength:`. The `%@` object format (3.0k cycles) is only ~0.9x simple-string OZLog thanks to fast nil-path handling. `LOG_INF` in minimal mode adds ~26% over `printk` (prefix formatting).
- **QEMU caveat**: these are instruction-accurate counts, not true cycle-accurate. Real hardware numbers will differ, but relative comparisons hold.

## Using in Your Project

### 1. Directory layout

Place the `objc/` runtime alongside your application (or use west to manage it):

```
my_app/
├── CMakeLists.txt
├── prj.conf
├── src/
│   └── main.m
└── ../objc/          # Objective-Z runtime module
```

### 2. CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20.0)

# Register Objective-Z as an extra module
set(ZEPHYR_EXTRA_MODULES "${CMAKE_CURRENT_SOURCE_DIR}/../objc/")

find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(my_app)

# Compile .m sources with Clang (ARC is always enabled)
objz_target_sources(app src/main.m)
```

### 3. prj.conf

```ini
# Required (ARC is always enabled for user .m files)
CONFIG_OBJZ=y

# Optional: Blocks (closures)
CONFIG_OBJZ_BLOCKS=y

# Optional: Collection classes (OZArray, OZDictionary)
CONFIG_OBJZ_COLLECTIONS=y

# Optional: Number class (OZNumber)
CONFIG_OBJZ_NUMBERS=y

# Optional: Boxed/collection literals (@42, @[...], @{...})
CONFIG_OBJZ_LITERALS=y

# Optional: Static allocation pools
CONFIG_OBJZ_STATIC_POOLS=y
```

### 4. Write your .m file

```objc
#import <objc/objc.h>       /* Core runtime: Object, id, SEL, Class */
#include <zephyr/kernel.h>
```

Use `Object` as the root class. ARC manages object lifetime automatically.

### 5. Build

```sh
west build -p -b mps2/an385 .
```

## CMake Helpers

| Function | Description |
|---|---|
| `objz_target_sources(target, files...)` | Routes `.m` to Clang (ARC), `.c` to GCC |

## Configuration

### Feature Flags

| Kconfig | Description | Depends on |
|---|---|---|
| `CONFIG_OBJZ` | Enable Objective-C runtime (ARC always on) | — |
| `CONFIG_OBJZ_DISPATCH_CACHE` | Per-class dispatch table cache | `OBJZ` |
| `CONFIG_OBJZ_BLOCKS` | Blocks (closures) with `-fblocks` | `OBJZ` |
| `CONFIG_OBJZ_COLLECTIONS` | Collection classes (OZArray, OZDictionary) | `OBJZ` |
| `CONFIG_OBJZ_NUMBERS` | Number class (OZNumber) | `OBJZ` |
| `CONFIG_OBJZ_LITERALS` | Boxed literals and collection literals | `OBJZ_COLLECTIONS`, `OBJZ_NUMBERS` |
| `CONFIG_OBJZ_STATIC_POOLS` | Per-class static allocation pools | `OBJZ` |

### Tuning

Runtime table sizes (class, category, protocol, hash, dispatch) are
auto-computed from source analysis at build time via tree-sitter.
Set a non-zero value in `prj.conf` to override any auto-computed size.

| Kconfig | Default | Description |
|---|---|---|
| `CONFIG_OBJZ_MEM_POOL_SIZE` | 4096 | Heap size in bytes |
| `CONFIG_OBJZ_LOG_BUFFER_SIZE` | 128 | OZLog format buffer size |

## Build Commands

Requires [just](https://github.com/casey/just). Default board: `mps2/an385`.

| Command | Description |
|---|---|
| `just build` | Incremental build |
| `just rebuild` | Pristine rebuild |
| `just run` | Run in QEMU |
| `just flash` | Flash to hardware |
| `just monitor` | Serial monitor (tio) |
| `just clean` | Remove build directory |
| `just test` | Run twister on all samples |

Override defaults:

```sh
just project_dir=samples/arc_demo board=nucleo_f429zi rebuild
just flash
```

## ARC Guide

Automatic Reference Counting (ARC) lets the compiler manage `retain`/`release` calls for you. ARC is always enabled — all `.m` files compiled via `objz_target_sources()` use `-fobjc-arc`.

### How it works

Under ARC, Clang inserts `objc_retain`/`objc_release` calls at compile time. You never call `retain`, `release`, or `autorelease` explicitly — the compiler does it.

```objc
#import <Foundation/Foundation.h>

@interface Sensor : Object
@property (nonatomic, strong) id delegate;
- (void)measure;
@end

@implementation Sensor
@synthesize delegate = _delegate;

- (void)measure
{
    OZLog("Measuring...");
}

- (void)dealloc
{
    OZLog("Sensor deallocated");
    /* ARC auto-inserts [super dealloc] — do NOT call it yourself */
}
@end

void demo(void)
{
    Sensor *s = [[Sensor alloc] init]; /* rc=1 */
    [s measure];
    /* ARC releases s here — dealloc fires automatically */
}
```

### Strong properties and `.cxx_destruct`

When a class has `strong` properties (or ivars), ARC generates a hidden `.cxx_destruct` method that releases them before `-dealloc` runs. This works through the entire class hierarchy:

```objc
@interface Driver : Object
@property (nonatomic, strong) Sensor *sensor;
@end

@implementation Driver
@synthesize sensor = _sensor;

- (void)dealloc
{
    OZLog("Driver deallocated");
    /* .cxx_destruct already released _sensor before we get here */
}
@end

void demo(void)
{
    Driver *d = [[Driver alloc] init];
    d.sensor = [[Sensor alloc] init];
    /* ARC releases d → .cxx_destruct releases sensor → both dealloc */
}
```

### `@autoreleasepool` — when you need it

ARC handles most cases, but `@autoreleasepool` is critical in **loops that create many temporary objects**. Without it, temporaries accumulate until the enclosing scope ends — a serious problem on memory-constrained embedded systems.

```objc
/* BAD: all 1000 temporaries live until function returns */
void process_bad(void)
{
    for (int i = 0; i < 1000; i++) {
        id tmp = [SomeFactory create]; /* autoreleased by factory */
        /* tmp stays alive... */
    }
    /* all 1000 objects released here — peak memory is huge */
}

/* GOOD: each iteration drains its pool */
void process_good(void)
{
    for (int i = 0; i < 1000; i++) {
        @autoreleasepool {
            id tmp = [SomeFactory create];
            /* tmp released at end of @autoreleasepool block */
        }
    }
    /* peak memory: only 1 object at a time */
}
```

Use `@autoreleasepool` when:
- **Loops** create temporary objects (factory methods, `-description`, string operations)
- **Worker threads** — each thread needs its own pool before any autorelease happens
- **Batch processing** — any code path that allocates many short-lived objects

### Retain cycles — the one thing ARC cannot fix

ARC has no weak references on this runtime. If two objects hold `strong` references to each other, neither can be deallocated:

```objc
@interface Node : Object
@property (nonatomic, strong) Node *next;
@end

void leak(void)
{
    Node *a = [[Node alloc] init];
    Node *b = [[Node alloc] init];
    a.next = b;
    b.next = a; /* cycle: a→b→a */
    /* ARC releases locals, but the cycle keeps both alive — LEAK */
}
```

Avoid cycles by breaking the reference chain before the owner goes out of scope:

```objc
void no_leak(void)
{
    Node *a = [[Node alloc] init];
    Node *b = [[Node alloc] init];
    a.next = b;
    b.next = a;

    /* Break cycle before scope exit */
    b.next = nil;
    /* Now: a→b, b→nil. ARC releases a → releases b → both dealloc */
}
```

### ARC rules summary

| Do | Don't |
|---|---|
| Use `objz_target_sources()` in CMake | Call `retain`, `release`, or `autorelease` |
| Let the compiler manage object lifetime | Call `[super dealloc]` — ARC inserts it |
| Use `@autoreleasepool` in loops/threads | Create strong reference cycles |
| Use `strong` properties for ownership | Call `retain`/`release`/`autorelease` manually |
| Break cycles manually before scope exit | Assume temporaries are released immediately |

### Static pools with ARC

Static allocation pools (`CONFIG_OBJZ_STATIC_POOLS`) work transparently with ARC. Pools are auto-generated by `objz_gen_pools.py` from Clang AST analysis — no manual `pools.c` files needed. The build system determines instance sizes and max concurrent counts automatically.

```objc
/* main.m — compiled with ARC */
void demo(void)
{
    Sensor *s = [[Sensor alloc] init]; /* allocated from slab */
    [s measure];
    /* ARC releases s → dealloc returns block to slab */
}
```

## License

Apache-2.0
